// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: unit_conversions.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createUnitConversion = `-- name: CreateUnitConversion :one
INSERT INTO unit_conversions (tenant_id, from_unit_id, to_unit_id, conversion_factor)
VALUES ($1, $2, $3, $4)
RETURNING id, tenant_id, from_unit_id, to_unit_id, conversion_factor, created_at, updated_at
`

type CreateUnitConversionParams struct {
	TenantID         uuid.UUID      `json:"tenant_id"`
	FromUnitID       uuid.UUID      `json:"from_unit_id"`
	ToUnitID         uuid.UUID      `json:"to_unit_id"`
	ConversionFactor pgtype.Numeric `json:"conversion_factor"`
}

func (q *Queries) CreateUnitConversion(ctx context.Context, arg CreateUnitConversionParams) (UnitConversion, error) {
	row := q.db.QueryRow(ctx, createUnitConversion,
		arg.TenantID,
		arg.FromUnitID,
		arg.ToUnitID,
		arg.ConversionFactor,
	)
	var i UnitConversion
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.FromUnitID,
		&i.ToUnitID,
		&i.ConversionFactor,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUnitConversion = `-- name: DeleteUnitConversion :exec
DELETE FROM unit_conversions
WHERE id = $1
`

func (q *Queries) DeleteUnitConversion(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUnitConversion, id)
	return err
}

const getConversionFactor = `-- name: GetConversionFactor :one
SELECT conversion_factor FROM unit_conversions
WHERE tenant_id = $1
  AND from_unit_id = $2
  AND to_unit_id = $3
`

type GetConversionFactorParams struct {
	TenantID   uuid.UUID `json:"tenant_id"`
	FromUnitID uuid.UUID `json:"from_unit_id"`
	ToUnitID   uuid.UUID `json:"to_unit_id"`
}

func (q *Queries) GetConversionFactor(ctx context.Context, arg GetConversionFactorParams) (pgtype.Numeric, error) {
	row := q.db.QueryRow(ctx, getConversionFactor, arg.TenantID, arg.FromUnitID, arg.ToUnitID)
	var conversion_factor pgtype.Numeric
	err := row.Scan(&conversion_factor)
	return conversion_factor, err
}

const getUnitConversionByID = `-- name: GetUnitConversionByID :one
SELECT id, tenant_id, from_unit_id, to_unit_id, conversion_factor, created_at, updated_at FROM unit_conversions
WHERE id = $1
`

func (q *Queries) GetUnitConversionByID(ctx context.Context, id uuid.UUID) (UnitConversion, error) {
	row := q.db.QueryRow(ctx, getUnitConversionByID, id)
	var i UnitConversion
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.FromUnitID,
		&i.ToUnitID,
		&i.ConversionFactor,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUnitConversionsByTenant = `-- name: GetUnitConversionsByTenant :many
SELECT uc.id, uc.tenant_id, uc.from_unit_id, uc.to_unit_id, uc.conversion_factor, uc.created_at, uc.updated_at,
       fu.name AS from_unit_name,
       tu.name AS to_unit_name
FROM unit_conversions uc
INNER JOIN units fu ON fu.id = uc.from_unit_id
INNER JOIN units tu ON tu.id = uc.to_unit_id
WHERE uc.tenant_id = $1
ORDER BY fu.name ASC, tu.name ASC
`

type GetUnitConversionsByTenantRow struct {
	ID               uuid.UUID          `json:"id"`
	TenantID         uuid.UUID          `json:"tenant_id"`
	FromUnitID       uuid.UUID          `json:"from_unit_id"`
	ToUnitID         uuid.UUID          `json:"to_unit_id"`
	ConversionFactor pgtype.Numeric     `json:"conversion_factor"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	FromUnitName     string             `json:"from_unit_name"`
	ToUnitName       string             `json:"to_unit_name"`
}

func (q *Queries) GetUnitConversionsByTenant(ctx context.Context, tenantID uuid.UUID) ([]GetUnitConversionsByTenantRow, error) {
	rows, err := q.db.Query(ctx, getUnitConversionsByTenant, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUnitConversionsByTenantRow{}
	for rows.Next() {
		var i GetUnitConversionsByTenantRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.FromUnitID,
			&i.ToUnitID,
			&i.ConversionFactor,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FromUnitName,
			&i.ToUnitName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUnitConversion = `-- name: UpdateUnitConversion :one
UPDATE unit_conversions
SET from_unit_id = $1,
    to_unit_id = $2,
    conversion_factor = $3,
    updated_at = NOW()
WHERE id = $4
RETURNING id, tenant_id, from_unit_id, to_unit_id, conversion_factor, created_at, updated_at
`

type UpdateUnitConversionParams struct {
	FromUnitID       uuid.UUID      `json:"from_unit_id"`
	ToUnitID         uuid.UUID      `json:"to_unit_id"`
	ConversionFactor pgtype.Numeric `json:"conversion_factor"`
	ID               uuid.UUID      `json:"id"`
}

func (q *Queries) UpdateUnitConversion(ctx context.Context, arg UpdateUnitConversionParams) (UnitConversion, error) {
	row := q.db.QueryRow(ctx, updateUnitConversion,
		arg.FromUnitID,
		arg.ToUnitID,
		arg.ConversionFactor,
		arg.ID,
	)
	var i UnitConversion
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.FromUnitID,
		&i.ToUnitID,
		&i.ConversionFactor,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
