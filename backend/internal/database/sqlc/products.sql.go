// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: products.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countProductsByTenant = `-- name: CountProductsByTenant :one
SELECT COUNT(*) FROM products
WHERE tenant_id = $1
`

func (q *Queries) CountProductsByTenant(ctx context.Context, tenantID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countProductsByTenant, tenantID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProductsByTenantAndCategory = `-- name: CountProductsByTenantAndCategory :one
SELECT COUNT(*) FROM products
WHERE tenant_id = $1 AND category_id = $2
`

type CountProductsByTenantAndCategoryParams struct {
	TenantID   uuid.UUID `json:"tenant_id"`
	CategoryID uuid.UUID `json:"category_id"`
}

func (q *Queries) CountProductsByTenantAndCategory(ctx context.Context, arg CountProductsByTenantAndCategoryParams) (int64, error) {
	row := q.db.QueryRow(ctx, countProductsByTenantAndCategory, arg.TenantID, arg.CategoryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPriceTier = `-- name: CreatePriceTier :one
INSERT INTO price_tiers (product_id, product_variant_id, min_quantity, price)
VALUES ($1, $2, $3, $4)
RETURNING id, product_id, product_variant_id, min_quantity, price, created_at, updated_at
`

type CreatePriceTierParams struct {
	ProductID        pgtype.UUID    `json:"product_id"`
	ProductVariantID pgtype.UUID    `json:"product_variant_id"`
	MinQuantity      int32          `json:"min_quantity"`
	Price            pgtype.Numeric `json:"price"`
}

func (q *Queries) CreatePriceTier(ctx context.Context, arg CreatePriceTierParams) (PriceTier, error) {
	row := q.db.QueryRow(ctx, createPriceTier,
		arg.ProductID,
		arg.ProductVariantID,
		arg.MinQuantity,
		arg.Price,
	)
	var i PriceTier
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ProductVariantID,
		&i.MinQuantity,
		&i.Price,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProduct = `-- name: CreateProduct :one
INSERT INTO products (tenant_id, category_id, name, description, has_variants, sell_method, status, tax_rate, discount_rate, min_quantity, max_quantity, pricing_mode, markup_value, fixed_price)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
RETURNING id, tenant_id, category_id, name, description, has_variants, sell_method, status, tax_rate, discount_rate, min_quantity, max_quantity, pricing_mode, markup_value, fixed_price, is_active, created_at, updated_at
`

type CreateProductParams struct {
	TenantID     uuid.UUID      `json:"tenant_id"`
	CategoryID   uuid.UUID      `json:"category_id"`
	Name         string         `json:"name"`
	Description  pgtype.Text    `json:"description"`
	HasVariants  bool           `json:"has_variants"`
	SellMethod   SellMethod     `json:"sell_method"`
	Status       ProductStatus  `json:"status"`
	TaxRate      pgtype.Numeric `json:"tax_rate"`
	DiscountRate pgtype.Numeric `json:"discount_rate"`
	MinQuantity  pgtype.Numeric `json:"min_quantity"`
	MaxQuantity  pgtype.Numeric `json:"max_quantity"`
	PricingMode  pgtype.Text    `json:"pricing_mode"`
	MarkupValue  pgtype.Numeric `json:"markup_value"`
	FixedPrice   pgtype.Numeric `json:"fixed_price"`
}

func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.TenantID,
		arg.CategoryID,
		arg.Name,
		arg.Description,
		arg.HasVariants,
		arg.SellMethod,
		arg.Status,
		arg.TaxRate,
		arg.DiscountRate,
		arg.MinQuantity,
		arg.MaxQuantity,
		arg.PricingMode,
		arg.MarkupValue,
		arg.FixedPrice,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CategoryID,
		&i.Name,
		&i.Description,
		&i.HasVariants,
		&i.SellMethod,
		&i.Status,
		&i.TaxRate,
		&i.DiscountRate,
		&i.MinQuantity,
		&i.MaxQuantity,
		&i.PricingMode,
		&i.MarkupValue,
		&i.FixedPrice,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProductImage = `-- name: CreateProductImage :one
INSERT INTO product_images (product_id, image_url, sort_order)
VALUES ($1, $2, $3)
RETURNING id, product_id, image_url, sort_order, created_at, updated_at
`

type CreateProductImageParams struct {
	ProductID uuid.UUID `json:"product_id"`
	ImageUrl  string    `json:"image_url"`
	SortOrder int32     `json:"sort_order"`
}

func (q *Queries) CreateProductImage(ctx context.Context, arg CreateProductImageParams) (ProductImage, error) {
	row := q.db.QueryRow(ctx, createProductImage, arg.ProductID, arg.ImageUrl, arg.SortOrder)
	var i ProductImage
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ImageUrl,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProductVariant = `-- name: CreateProductVariant :one
INSERT INTO product_variants (product_id, sku, barcode, unit_id, retail_price)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, product_id, sku, barcode, unit_id, retail_price, is_active, created_at, updated_at
`

type CreateProductVariantParams struct {
	ProductID   uuid.UUID      `json:"product_id"`
	Sku         string         `json:"sku"`
	Barcode     pgtype.Text    `json:"barcode"`
	UnitID      uuid.UUID      `json:"unit_id"`
	RetailPrice pgtype.Numeric `json:"retail_price"`
}

func (q *Queries) CreateProductVariant(ctx context.Context, arg CreateProductVariantParams) (ProductVariant, error) {
	row := q.db.QueryRow(ctx, createProductVariant,
		arg.ProductID,
		arg.Sku,
		arg.Barcode,
		arg.UnitID,
		arg.RetailPrice,
	)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Sku,
		&i.Barcode,
		&i.UnitID,
		&i.RetailPrice,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProductVariantImage = `-- name: CreateProductVariantImage :one
INSERT INTO product_variant_images (product_variant_id, image_url, sort_order)
VALUES ($1, $2, $3)
RETURNING id, product_variant_id, image_url, sort_order, created_at, updated_at
`

type CreateProductVariantImageParams struct {
	ProductVariantID uuid.UUID `json:"product_variant_id"`
	ImageUrl         string    `json:"image_url"`
	SortOrder        int32     `json:"sort_order"`
}

func (q *Queries) CreateProductVariantImage(ctx context.Context, arg CreateProductVariantImageParams) (ProductVariantImage, error) {
	row := q.db.QueryRow(ctx, createProductVariantImage, arg.ProductVariantID, arg.ImageUrl, arg.SortOrder)
	var i ProductVariantImage
	err := row.Scan(
		&i.ID,
		&i.ProductVariantID,
		&i.ImageUrl,
		&i.SortOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createProductVariantValue = `-- name: CreateProductVariantValue :exec
INSERT INTO product_variant_values (product_variant_id, variant_value_id)
VALUES ($1, $2)
`

type CreateProductVariantValueParams struct {
	ProductVariantID uuid.UUID `json:"product_variant_id"`
	VariantValueID   uuid.UUID `json:"variant_value_id"`
}

func (q *Queries) CreateProductVariantValue(ctx context.Context, arg CreateProductVariantValueParams) error {
	_, err := q.db.Exec(ctx, createProductVariantValue, arg.ProductVariantID, arg.VariantValueID)
	return err
}

const deactivateProduct = `-- name: DeactivateProduct :exec
UPDATE products
SET status = 'inactive', is_active = FALSE, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) DeactivateProduct(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deactivateProduct, id)
	return err
}

const deletePriceTiersByProduct = `-- name: DeletePriceTiersByProduct :exec
DELETE FROM price_tiers WHERE product_id = $1
`

func (q *Queries) DeletePriceTiersByProduct(ctx context.Context, productID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePriceTiersByProduct, productID)
	return err
}

const deletePriceTiersByVariant = `-- name: DeletePriceTiersByVariant :exec
DELETE FROM price_tiers WHERE product_variant_id = $1
`

func (q *Queries) DeletePriceTiersByVariant(ctx context.Context, productVariantID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePriceTiersByVariant, productVariantID)
	return err
}

const deleteProductImage = `-- name: DeleteProductImage :exec
DELETE FROM product_images WHERE id = $1
`

func (q *Queries) DeleteProductImage(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProductImage, id)
	return err
}

const deleteProductImagesByProduct = `-- name: DeleteProductImagesByProduct :exec
DELETE FROM product_images WHERE product_id = $1
`

func (q *Queries) DeleteProductImagesByProduct(ctx context.Context, productID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProductImagesByProduct, productID)
	return err
}

const deleteProductVariantValues = `-- name: DeleteProductVariantValues :exec
DELETE FROM product_variant_values WHERE product_variant_id = $1
`

func (q *Queries) DeleteProductVariantValues(ctx context.Context, productVariantID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProductVariantValues, productVariantID)
	return err
}

const deleteProductVariantsByProduct = `-- name: DeleteProductVariantsByProduct :exec
DELETE FROM product_variants WHERE product_id = $1
`

func (q *Queries) DeleteProductVariantsByProduct(ctx context.Context, productID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteProductVariantsByProduct, productID)
	return err
}

const getPriceTiersByProduct = `-- name: GetPriceTiersByProduct :many
SELECT id, product_id, product_variant_id, min_quantity, price, created_at, updated_at FROM price_tiers
WHERE product_id = $1
ORDER BY min_quantity ASC
`

func (q *Queries) GetPriceTiersByProduct(ctx context.Context, productID pgtype.UUID) ([]PriceTier, error) {
	rows, err := q.db.Query(ctx, getPriceTiersByProduct, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PriceTier{}
	for rows.Next() {
		var i PriceTier
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ProductVariantID,
			&i.MinQuantity,
			&i.Price,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPriceTiersByVariant = `-- name: GetPriceTiersByVariant :many
SELECT id, product_id, product_variant_id, min_quantity, price, created_at, updated_at FROM price_tiers
WHERE product_variant_id = $1
ORDER BY min_quantity ASC
`

func (q *Queries) GetPriceTiersByVariant(ctx context.Context, productVariantID pgtype.UUID) ([]PriceTier, error) {
	rows, err := q.db.Query(ctx, getPriceTiersByVariant, productVariantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []PriceTier{}
	for rows.Next() {
		var i PriceTier
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ProductVariantID,
			&i.MinQuantity,
			&i.Price,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductByID = `-- name: GetProductByID :one
SELECT p.id, p.tenant_id, p.category_id, p.name, p.description, p.has_variants, p.sell_method, p.status, p.tax_rate, p.discount_rate, p.min_quantity, p.max_quantity, p.pricing_mode, p.markup_value, p.fixed_price, p.is_active, p.created_at, p.updated_at, c.name AS category_name
FROM products p
JOIN categories c ON c.id = p.category_id
WHERE p.id = $1
`

type GetProductByIDRow struct {
	ID           uuid.UUID          `json:"id"`
	TenantID     uuid.UUID          `json:"tenant_id"`
	CategoryID   uuid.UUID          `json:"category_id"`
	Name         string             `json:"name"`
	Description  pgtype.Text        `json:"description"`
	HasVariants  bool               `json:"has_variants"`
	SellMethod   SellMethod         `json:"sell_method"`
	Status       ProductStatus      `json:"status"`
	TaxRate      pgtype.Numeric     `json:"tax_rate"`
	DiscountRate pgtype.Numeric     `json:"discount_rate"`
	MinQuantity  pgtype.Numeric     `json:"min_quantity"`
	MaxQuantity  pgtype.Numeric     `json:"max_quantity"`
	PricingMode  pgtype.Text        `json:"pricing_mode"`
	MarkupValue  pgtype.Numeric     `json:"markup_value"`
	FixedPrice   pgtype.Numeric     `json:"fixed_price"`
	IsActive     bool               `json:"is_active"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	CategoryName string             `json:"category_name"`
}

func (q *Queries) GetProductByID(ctx context.Context, id uuid.UUID) (GetProductByIDRow, error) {
	row := q.db.QueryRow(ctx, getProductByID, id)
	var i GetProductByIDRow
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CategoryID,
		&i.Name,
		&i.Description,
		&i.HasVariants,
		&i.SellMethod,
		&i.Status,
		&i.TaxRate,
		&i.DiscountRate,
		&i.MinQuantity,
		&i.MaxQuantity,
		&i.PricingMode,
		&i.MarkupValue,
		&i.FixedPrice,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CategoryName,
	)
	return i, err
}

const getProductImages = `-- name: GetProductImages :many
SELECT id, product_id, image_url, sort_order, created_at, updated_at FROM product_images
WHERE product_id = $1
ORDER BY sort_order ASC
`

func (q *Queries) GetProductImages(ctx context.Context, productID uuid.UUID) ([]ProductImage, error) {
	rows, err := q.db.Query(ctx, getProductImages, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductImage{}
	for rows.Next() {
		var i ProductImage
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ImageUrl,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductVariantImages = `-- name: GetProductVariantImages :many
SELECT id, product_variant_id, image_url, sort_order, created_at, updated_at FROM product_variant_images
WHERE product_variant_id = $1
ORDER BY sort_order ASC
`

func (q *Queries) GetProductVariantImages(ctx context.Context, productVariantID uuid.UUID) ([]ProductVariantImage, error) {
	rows, err := q.db.Query(ctx, getProductVariantImages, productVariantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ProductVariantImage{}
	for rows.Next() {
		var i ProductVariantImage
		if err := rows.Scan(
			&i.ID,
			&i.ProductVariantID,
			&i.ImageUrl,
			&i.SortOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductVariantValues = `-- name: GetProductVariantValues :many
SELECT pvv.id, pvv.product_variant_id, pvv.variant_value_id, vv.value, v.id AS variant_id, v.name AS variant_name
FROM product_variant_values pvv
JOIN variant_values vv ON vv.id = pvv.variant_value_id
JOIN variants v ON v.id = vv.variant_id
WHERE pvv.product_variant_id = $1
ORDER BY v.name ASC
`

type GetProductVariantValuesRow struct {
	ID               uuid.UUID `json:"id"`
	ProductVariantID uuid.UUID `json:"product_variant_id"`
	VariantValueID   uuid.UUID `json:"variant_value_id"`
	Value            string    `json:"value"`
	VariantID        uuid.UUID `json:"variant_id"`
	VariantName      string    `json:"variant_name"`
}

func (q *Queries) GetProductVariantValues(ctx context.Context, productVariantID uuid.UUID) ([]GetProductVariantValuesRow, error) {
	rows, err := q.db.Query(ctx, getProductVariantValues, productVariantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductVariantValuesRow{}
	for rows.Next() {
		var i GetProductVariantValuesRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductVariantID,
			&i.VariantValueID,
			&i.Value,
			&i.VariantID,
			&i.VariantName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductVariants = `-- name: GetProductVariants :many
SELECT pv.id, pv.product_id, pv.sku, pv.barcode, pv.unit_id, pv.retail_price, pv.is_active, pv.created_at, pv.updated_at, u.name AS unit_name
FROM product_variants pv
JOIN units u ON u.id = pv.unit_id
WHERE pv.product_id = $1
ORDER BY pv.created_at ASC
`

type GetProductVariantsRow struct {
	ID          uuid.UUID          `json:"id"`
	ProductID   uuid.UUID          `json:"product_id"`
	Sku         string             `json:"sku"`
	Barcode     pgtype.Text        `json:"barcode"`
	UnitID      uuid.UUID          `json:"unit_id"`
	RetailPrice pgtype.Numeric     `json:"retail_price"`
	IsActive    bool               `json:"is_active"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	UnitName    string             `json:"unit_name"`
}

func (q *Queries) GetProductVariants(ctx context.Context, productID uuid.UUID) ([]GetProductVariantsRow, error) {
	rows, err := q.db.Query(ctx, getProductVariants, productID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductVariantsRow{}
	for rows.Next() {
		var i GetProductVariantsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.Sku,
			&i.Barcode,
			&i.UnitID,
			&i.RetailPrice,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UnitName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByTenant = `-- name: GetProductsByTenant :many
SELECT p.id, p.tenant_id, p.category_id, p.name, p.description, p.has_variants, p.sell_method, p.status, p.tax_rate, p.discount_rate, p.min_quantity, p.max_quantity, p.pricing_mode, p.markup_value, p.fixed_price, p.is_active, p.created_at, p.updated_at, c.name AS category_name
FROM products p
JOIN categories c ON c.id = p.category_id
WHERE p.tenant_id = $1
ORDER BY p.created_at DESC
LIMIT $3 OFFSET $2
`

type GetProductsByTenantParams struct {
	TenantID  uuid.UUID `json:"tenant_id"`
	OffsetVal int32     `json:"offset_val"`
	LimitVal  int32     `json:"limit_val"`
}

type GetProductsByTenantRow struct {
	ID           uuid.UUID          `json:"id"`
	TenantID     uuid.UUID          `json:"tenant_id"`
	CategoryID   uuid.UUID          `json:"category_id"`
	Name         string             `json:"name"`
	Description  pgtype.Text        `json:"description"`
	HasVariants  bool               `json:"has_variants"`
	SellMethod   SellMethod         `json:"sell_method"`
	Status       ProductStatus      `json:"status"`
	TaxRate      pgtype.Numeric     `json:"tax_rate"`
	DiscountRate pgtype.Numeric     `json:"discount_rate"`
	MinQuantity  pgtype.Numeric     `json:"min_quantity"`
	MaxQuantity  pgtype.Numeric     `json:"max_quantity"`
	PricingMode  pgtype.Text        `json:"pricing_mode"`
	MarkupValue  pgtype.Numeric     `json:"markup_value"`
	FixedPrice   pgtype.Numeric     `json:"fixed_price"`
	IsActive     bool               `json:"is_active"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	CategoryName string             `json:"category_name"`
}

func (q *Queries) GetProductsByTenant(ctx context.Context, arg GetProductsByTenantParams) ([]GetProductsByTenantRow, error) {
	rows, err := q.db.Query(ctx, getProductsByTenant, arg.TenantID, arg.OffsetVal, arg.LimitVal)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductsByTenantRow{}
	for rows.Next() {
		var i GetProductsByTenantRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.CategoryID,
			&i.Name,
			&i.Description,
			&i.HasVariants,
			&i.SellMethod,
			&i.Status,
			&i.TaxRate,
			&i.DiscountRate,
			&i.MinQuantity,
			&i.MaxQuantity,
			&i.PricingMode,
			&i.MarkupValue,
			&i.FixedPrice,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProductsByTenantAndCategory = `-- name: GetProductsByTenantAndCategory :many
SELECT p.id, p.tenant_id, p.category_id, p.name, p.description, p.has_variants, p.sell_method, p.status, p.tax_rate, p.discount_rate, p.min_quantity, p.max_quantity, p.pricing_mode, p.markup_value, p.fixed_price, p.is_active, p.created_at, p.updated_at, c.name AS category_name
FROM products p
JOIN categories c ON c.id = p.category_id
WHERE p.tenant_id = $1 AND p.category_id = $2
ORDER BY p.created_at DESC
LIMIT $4 OFFSET $3
`

type GetProductsByTenantAndCategoryParams struct {
	TenantID   uuid.UUID `json:"tenant_id"`
	CategoryID uuid.UUID `json:"category_id"`
	OffsetVal  int32     `json:"offset_val"`
	LimitVal   int32     `json:"limit_val"`
}

type GetProductsByTenantAndCategoryRow struct {
	ID           uuid.UUID          `json:"id"`
	TenantID     uuid.UUID          `json:"tenant_id"`
	CategoryID   uuid.UUID          `json:"category_id"`
	Name         string             `json:"name"`
	Description  pgtype.Text        `json:"description"`
	HasVariants  bool               `json:"has_variants"`
	SellMethod   SellMethod         `json:"sell_method"`
	Status       ProductStatus      `json:"status"`
	TaxRate      pgtype.Numeric     `json:"tax_rate"`
	DiscountRate pgtype.Numeric     `json:"discount_rate"`
	MinQuantity  pgtype.Numeric     `json:"min_quantity"`
	MaxQuantity  pgtype.Numeric     `json:"max_quantity"`
	PricingMode  pgtype.Text        `json:"pricing_mode"`
	MarkupValue  pgtype.Numeric     `json:"markup_value"`
	FixedPrice   pgtype.Numeric     `json:"fixed_price"`
	IsActive     bool               `json:"is_active"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	CategoryName string             `json:"category_name"`
}

func (q *Queries) GetProductsByTenantAndCategory(ctx context.Context, arg GetProductsByTenantAndCategoryParams) ([]GetProductsByTenantAndCategoryRow, error) {
	rows, err := q.db.Query(ctx, getProductsByTenantAndCategory,
		arg.TenantID,
		arg.CategoryID,
		arg.OffsetVal,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetProductsByTenantAndCategoryRow{}
	for rows.Next() {
		var i GetProductsByTenantAndCategoryRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.CategoryID,
			&i.Name,
			&i.Description,
			&i.HasVariants,
			&i.SellMethod,
			&i.Status,
			&i.TaxRate,
			&i.DiscountRate,
			&i.MinQuantity,
			&i.MaxQuantity,
			&i.PricingMode,
			&i.MarkupValue,
			&i.FixedPrice,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CategoryName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products
SET name = $1,
    description = $2,
    category_id = $3,
    has_variants = $4,
    sell_method = $5,
    status = $6,
    tax_rate = $7,
    discount_rate = $8,
    min_quantity = $9,
    max_quantity = $10,
    pricing_mode = $11,
    markup_value = $12,
    fixed_price = $13,
    is_active = $14,
    updated_at = NOW()
WHERE id = $15
RETURNING id, tenant_id, category_id, name, description, has_variants, sell_method, status, tax_rate, discount_rate, min_quantity, max_quantity, pricing_mode, markup_value, fixed_price, is_active, created_at, updated_at
`

type UpdateProductParams struct {
	Name         string         `json:"name"`
	Description  pgtype.Text    `json:"description"`
	CategoryID   uuid.UUID      `json:"category_id"`
	HasVariants  bool           `json:"has_variants"`
	SellMethod   SellMethod     `json:"sell_method"`
	Status       ProductStatus  `json:"status"`
	TaxRate      pgtype.Numeric `json:"tax_rate"`
	DiscountRate pgtype.Numeric `json:"discount_rate"`
	MinQuantity  pgtype.Numeric `json:"min_quantity"`
	MaxQuantity  pgtype.Numeric `json:"max_quantity"`
	PricingMode  pgtype.Text    `json:"pricing_mode"`
	MarkupValue  pgtype.Numeric `json:"markup_value"`
	FixedPrice   pgtype.Numeric `json:"fixed_price"`
	IsActive     bool           `json:"is_active"`
	ID           uuid.UUID      `json:"id"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProduct,
		arg.Name,
		arg.Description,
		arg.CategoryID,
		arg.HasVariants,
		arg.SellMethod,
		arg.Status,
		arg.TaxRate,
		arg.DiscountRate,
		arg.MinQuantity,
		arg.MaxQuantity,
		arg.PricingMode,
		arg.MarkupValue,
		arg.FixedPrice,
		arg.IsActive,
		arg.ID,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.CategoryID,
		&i.Name,
		&i.Description,
		&i.HasVariants,
		&i.SellMethod,
		&i.Status,
		&i.TaxRate,
		&i.DiscountRate,
		&i.MinQuantity,
		&i.MaxQuantity,
		&i.PricingMode,
		&i.MarkupValue,
		&i.FixedPrice,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateProductVariant = `-- name: UpdateProductVariant :one
UPDATE product_variants
SET sku = $1,
    barcode = $2,
    unit_id = $3,
    retail_price = $4,
    is_active = $5,
    updated_at = NOW()
WHERE id = $6
RETURNING id, product_id, sku, barcode, unit_id, retail_price, is_active, created_at, updated_at
`

type UpdateProductVariantParams struct {
	Sku         string         `json:"sku"`
	Barcode     pgtype.Text    `json:"barcode"`
	UnitID      uuid.UUID      `json:"unit_id"`
	RetailPrice pgtype.Numeric `json:"retail_price"`
	IsActive    bool           `json:"is_active"`
	ID          uuid.UUID      `json:"id"`
}

func (q *Queries) UpdateProductVariant(ctx context.Context, arg UpdateProductVariantParams) (ProductVariant, error) {
	row := q.db.QueryRow(ctx, updateProductVariant,
		arg.Sku,
		arg.Barcode,
		arg.UnitID,
		arg.RetailPrice,
		arg.IsActive,
		arg.ID,
	)
	var i ProductVariant
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.Sku,
		&i.Barcode,
		&i.UnitID,
		&i.RetailPrice,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
