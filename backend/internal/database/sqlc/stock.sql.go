// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: stock.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countStockLedgerEntries = `-- name: CountStockLedgerEntries :one
SELECT COUNT(*) FROM stock_ledger
WHERE product_variant_id = $1
  AND warehouse_id = $2
`

type CountStockLedgerEntriesParams struct {
	ProductVariantID uuid.UUID `json:"product_variant_id"`
	WarehouseID      uuid.UUID `json:"warehouse_id"`
}

func (q *Queries) CountStockLedgerEntries(ctx context.Context, arg CountStockLedgerEntriesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countStockLedgerEntries, arg.ProductVariantID, arg.WarehouseID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createStockLedgerEntry = `-- name: CreateStockLedgerEntry :one
INSERT INTO stock_ledger (tenant_id, product_variant_id, warehouse_id, quantity, unit_id, reason, reference_type, reference_id, notes)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, tenant_id, product_variant_id, warehouse_id, quantity, unit_id, reason, reference_type, reference_id, notes, created_at
`

type CreateStockLedgerEntryParams struct {
	TenantID         uuid.UUID      `json:"tenant_id"`
	ProductVariantID uuid.UUID      `json:"product_variant_id"`
	WarehouseID      uuid.UUID      `json:"warehouse_id"`
	Quantity         pgtype.Numeric `json:"quantity"`
	UnitID           uuid.UUID      `json:"unit_id"`
	Reason           StockReason    `json:"reason"`
	ReferenceType    pgtype.Text    `json:"reference_type"`
	ReferenceID      pgtype.UUID    `json:"reference_id"`
	Notes            pgtype.Text    `json:"notes"`
}

func (q *Queries) CreateStockLedgerEntry(ctx context.Context, arg CreateStockLedgerEntryParams) (StockLedger, error) {
	row := q.db.QueryRow(ctx, createStockLedgerEntry,
		arg.TenantID,
		arg.ProductVariantID,
		arg.WarehouseID,
		arg.Quantity,
		arg.UnitID,
		arg.Reason,
		arg.ReferenceType,
		arg.ReferenceID,
		arg.Notes,
	)
	var i StockLedger
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ProductVariantID,
		&i.WarehouseID,
		&i.Quantity,
		&i.UnitID,
		&i.Reason,
		&i.ReferenceType,
		&i.ReferenceID,
		&i.Notes,
		&i.CreatedAt,
	)
	return i, err
}

const getCurrentStock = `-- name: GetCurrentStock :one
SELECT COALESCE(SUM(quantity), 0)::NUMERIC(12,4) AS current_stock
FROM stock_ledger
WHERE product_variant_id = $1
  AND warehouse_id = $2
`

type GetCurrentStockParams struct {
	ProductVariantID uuid.UUID `json:"product_variant_id"`
	WarehouseID      uuid.UUID `json:"warehouse_id"`
}

func (q *Queries) GetCurrentStock(ctx context.Context, arg GetCurrentStockParams) (pgtype.Numeric, error) {
	row := q.db.QueryRow(ctx, getCurrentStock, arg.ProductVariantID, arg.WarehouseID)
	var current_stock pgtype.Numeric
	err := row.Scan(&current_stock)
	return current_stock, err
}

const getStockByProduct = `-- name: GetStockByProduct :many
SELECT
    pv.id AS variant_id,
    pv.sku AS variant_sku,
    w.id AS warehouse_id,
    w.name AS warehouse_name,
    COALESCE(SUM(sl.quantity), 0)::NUMERIC(12,4) AS current_stock
FROM product_variants pv
CROSS JOIN warehouses w
LEFT JOIN stock_ledger sl ON sl.product_variant_id = pv.id AND sl.warehouse_id = w.id
WHERE pv.product_id = $1
  AND w.tenant_id = $2
  AND w.is_active = TRUE
GROUP BY pv.id, pv.sku, w.id, w.name
ORDER BY pv.sku, w.name
`

type GetStockByProductParams struct {
	ProductID uuid.UUID `json:"product_id"`
	TenantID  uuid.UUID `json:"tenant_id"`
}

type GetStockByProductRow struct {
	VariantID     uuid.UUID      `json:"variant_id"`
	VariantSku    string         `json:"variant_sku"`
	WarehouseID   uuid.UUID      `json:"warehouse_id"`
	WarehouseName string         `json:"warehouse_name"`
	CurrentStock  pgtype.Numeric `json:"current_stock"`
}

func (q *Queries) GetStockByProduct(ctx context.Context, arg GetStockByProductParams) ([]GetStockByProductRow, error) {
	rows, err := q.db.Query(ctx, getStockByProduct, arg.ProductID, arg.TenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStockByProductRow{}
	for rows.Next() {
		var i GetStockByProductRow
		if err := rows.Scan(
			&i.VariantID,
			&i.VariantSku,
			&i.WarehouseID,
			&i.WarehouseName,
			&i.CurrentStock,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStockLedgerEntries = `-- name: GetStockLedgerEntries :many
SELECT sl.id, sl.tenant_id, sl.product_variant_id, sl.warehouse_id, sl.quantity, sl.unit_id, sl.reason, sl.reference_type, sl.reference_id, sl.notes, sl.created_at, u.name AS unit_name
FROM stock_ledger sl
JOIN units u ON u.id = sl.unit_id
WHERE sl.product_variant_id = $1
  AND sl.warehouse_id = $2
ORDER BY sl.created_at DESC
LIMIT $4 OFFSET $3
`

type GetStockLedgerEntriesParams struct {
	ProductVariantID uuid.UUID `json:"product_variant_id"`
	WarehouseID      uuid.UUID `json:"warehouse_id"`
	OffsetVal        int32     `json:"offset_val"`
	LimitVal         int32     `json:"limit_val"`
}

type GetStockLedgerEntriesRow struct {
	ID               uuid.UUID          `json:"id"`
	TenantID         uuid.UUID          `json:"tenant_id"`
	ProductVariantID uuid.UUID          `json:"product_variant_id"`
	WarehouseID      uuid.UUID          `json:"warehouse_id"`
	Quantity         pgtype.Numeric     `json:"quantity"`
	UnitID           uuid.UUID          `json:"unit_id"`
	Reason           StockReason        `json:"reason"`
	ReferenceType    pgtype.Text        `json:"reference_type"`
	ReferenceID      pgtype.UUID        `json:"reference_id"`
	Notes            pgtype.Text        `json:"notes"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UnitName         string             `json:"unit_name"`
}

func (q *Queries) GetStockLedgerEntries(ctx context.Context, arg GetStockLedgerEntriesParams) ([]GetStockLedgerEntriesRow, error) {
	rows, err := q.db.Query(ctx, getStockLedgerEntries,
		arg.ProductVariantID,
		arg.WarehouseID,
		arg.OffsetVal,
		arg.LimitVal,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStockLedgerEntriesRow{}
	for rows.Next() {
		var i GetStockLedgerEntriesRow
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ProductVariantID,
			&i.WarehouseID,
			&i.Quantity,
			&i.UnitID,
			&i.Reason,
			&i.ReferenceType,
			&i.ReferenceID,
			&i.Notes,
			&i.CreatedAt,
			&i.UnitName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
